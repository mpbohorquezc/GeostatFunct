ggplot_KS(KS_SFD_PM10_l)
library(SpatFD)
library(gstat)
# Load data and coordinates
data(AirQualityBogota)
#s_0 nonsampled location. It could be data.frame or matrix and one or more locations of interest
newcoorden=data.frame(X=seq(93000,105000,len=100),Y=seq(97000,112000,len=100))
# Building the SpatFD object
SFD_PM10 <- SpatFD(PM10, coords = coord[, -1], basis = "Bsplines", nbasis = 17,norder=5, lambda = 0.00002, nharm=3)
# Semivariogram models for each spatial random field of scores
modelos <- list(vgm(psill = 2199288.58, "Wav", range = 1484.57, nugget =  0),
vgm(psill = 62640.74, "Mat", range = 1979.43, nugget = 0,kappa=0.68),
vgm(psill =37098.25, "Exp", range = 6433.16, nugget =  0))
KS_SFD_PM10_sc <- KS_scores_lambdas(SFD_PM10, newcoorden, method = "scores", model = modelos)
KS_SFD_PM10_l <- KS_scores_lambdas(SFD_PM10, newcoorden ,method = "lambda", model = modelos)
KS_SFD_PM10_both <- KS_scores_lambdas(SFD_PM10, newcoorden, method = "both", model = modelos)
ggplot_KS(KS_SFD_PM10_l)
ggplot_KS(KS_SFD_PM10_both,show.varpred = FALSE,
main = "Plot 1 - Using Scores",
main2 = "Plot 2 - Using Lambda",
ylab = "PM10")
ggplot_KS(KS_SFD_PM10_both)
ggmap_KS(KS_SFD_PM10_both,
map_path = map,
window_time = c(2108),
method = "lambda",
zmin = 50,
zmax = 120)
cokrig = COKS_scores_lambdas(SFD_PM10_NO2, newcoords, model1)
library(SpatFD)
data(COKMexico)
# Definimos nuestro objeto SpatFD
SFD_PM10_NO2 <- SpatFD(Mex_PM10, coords = coord_PM10, basis = "Fourier",
nbasis = 21, lambda = 0.000001, nharm = 2)
# Agregamos las observaciones de NO2 al objeto que creamos antes por medio del argumento add
SFD_PM10_NO2 <- SpatFD(NO2, coords = coord_NO2, basis = "Fourier",
nbasis = 27, lambda = 0.000001, nharm = 2,
add = SFD_PM10_NO2)
# Definimos los modelos de varianza de cada una de las variables
model1 <- gstat::vgm(647677.1,"Gau",23317.05)
model1 <- gstat::vgm(127633,"Wav",9408.63, add.to = model1)
# Especificamos la ubicación no muestreada
newcoords <- data.frame(x = 509926, y = 2179149)
cokrig = COKS_scores_lambdas(SFD_PM10_NO2, newcoords, model1)
str(cokrig)
cokrig$SFD
cokrig$modelfit
rm(list=ls())
aquifer=read.table("../data/aquifer.txt",head=T,dec=",")
rm(list=ls())
aquifer=read.table("data/aquifer.txt",head=T,dec=",")
head(aquifer)
rm(list=ls())
library(fields)
library(geoR)
library(akima)
aquifer <- read.table("data_7_GeoestadisticaGEOSTAT/aquifer.txt", head = TRUE, dec = ",")
# Instalar paquetes si es necesario
# install.packages(c("gstat", "sp", "raster", "ggplot2", "phylin"))
library(gstat)
library(sp)
library(raster)
install.packages('raster')
# Instalar paquetes si es necesario
library(gstat)
library(sp)
library(raster)
library(ggplot2)
library(phylin)
library('phylin')
install.packages('phylin')
# Calcular el variograma experimental
vgram <- variogram(value ~ 1, values)
# Instalar paquetes si es necesario
library(gstat)
library(sp)
library(raster)
library(ggplot2)
library(phylin)
# Generación de datos simulados para los ejemplos
set.seed(123)
coords <- data.frame(x = runif(10, 0, 100), y = runif(10, 0, 100))
values <- data.frame(value = rnorm(10))
coordinates(values) <- ~ x + y
# Instalar paquetes si es necesario
library(gstat)
library(sp)
library(raster)
library(ggplot2)
library(phylin)
# Generación de datos simulados para los ejemplos
set.seed(123)
coords <- data.frame(x = runif(10, 0, 100), y = runif(10, 0, 100))
values <- data.frame(value = rnorm(10))
coordinates(values) <- ~ x + y
# Instalar paquetes si es necesario
library(gstat)
library(sp)
library(raster)
library(ggplot2)
library(phylin)
# Generación de datos simulados para los ejemplos
set.seed(123)
coords <- data.frame(x = runif(10, 0, 100), y = runif(10, 0, 100))
values <- data.frame(value = rnorm(10))
# Combinar 'coords' y 'values' en un solo data frame
data <- cbind(coords, values)
# Convertir 'data' en un objeto espacial
coordinates(data) <- ~ x + y
proj4string(data) <- CRS("+proj=utm +zone=33 +datum=WGS84")
# Calcular el variograma experimental
vgram <- variogram(value ~ 1, values)
# Calcular el variograma experimental
vgram <- variogram(value ~ 1, data)
# Ajustar un modelo de variograma
model <- vgm(psill = 1, model = "Sph", range = 50, nugget = 0)
# Calcular el variograma experimental
vgram <- variogram(value ~ 1, data)
# Ajustar un modelo de variograma
model <- vgm(psill = 1, model = "Sph", range = 50, nugget = 0)
vfit <- fit.variogram(vgram, model)
# Crear una cuadrícula de predicción
grd <- expand.grid(x = seq(0, 100, by = 5), y = seq(0, 100, by = 5))
coordinates(grd) <- ~ x + y
gridded(grd) <- TRUE
proj4string(grd) <- CRS("+proj=utm +zone=33 +datum=WGS84")
# Kriging Simple
kriged_values <- krige(value ~ 1, values, grd, model = vfit, nmax = 5)
# Kriging Simple
kriged_values <- krige(value ~ 1, data, grd, model = vfit, nmax = 5)
# Visualización
spplot(kriged_values["var1.pred"], main = "Kriging Simple Prediction")
# Ajustar modelo de variograma para kriging ordinario
vgram <- variogram(value ~ 1, data)
vfit <- fit.variogram(vgram, model)
# Kriging ordinario
kriged_values_ordinary <- krige(value ~ 1, data, grd, model = vfit, nmax = 5)
# Visualización
spplot(kriged_values_ordinary["var1.pred"], main = "Kriging Ordinario Prediction")
# Añadir variables auxiliares al conjunto de datos
values$x <- coordinates(data)[,1]
values$y <- coordinates(data)[,2]
# Ajustar variograma
vgram_universal <- variogram(value ~ x + y, data)
vfit_universal <- fit.variogram(vgram_universal, vgm(model = "Sph", psill = 1, range = 50, nugget = 0))
# Kriging Universal
kriged_values_universal <- krige(value ~ x + y, data, grd, model = vfit_universal)
# Visualización
spplot(kriged_values_universal["var1.pred"], main = "Kriging Universal Prediction")
rm(list=ls())
library(openxlsx)
library(dplyr)
library(rgdal)
install.packages('rgdal')
rm(list=ls())
library(openxlsx)
library(dplyr)
#library(rgdal)
library(maptools)
install.packages('maptools')
rm(list=ls())
library(openxlsx)
library(dplyr)
#library(rgdal)
#library(maptools)
library(GISTools)
library(spdep)
library(readr)
library(car)
library(readxl)
library(psych)
library(rgdal)
rm(list=ls())
library(openxlsx)
library(dplyr)
#library(rgdal)
#library(maptools)
library(GISTools)
library(spdep)
library(readr)
library(car)
library(readxl)
library(psych)
library(FactoClass)
library(spdep)
require("GWmodel")
library("mapsRinteractive")
options(scipen = 999)
# Lectura de Datos
BASE <- read_excel("data/BASE.xlsx")
# Lectura del Shape de Colombia por Departamentos
Colombia = readOGR(dsn = "data/Geodatabase Colombia",
layer = "departamentos")
library(sf)
# Lectura de Datos
BASE <- read_excel("data/BASE.xlsx")
# Lectura del Shape de Colombia por Departamentos
Colombia = st_read(dsn = "data/Geodatabase Colombia", layer = "departamentos")
rm(list=ls())
library(openxlsx)
library(dplyr)
library(GISTools)
library(spdep)
library(readr)
library(car)
library(readxl)
library(psych)
library(sf)
library(FactoClass)
library(spdep)
require("GWmodel")
library("mapsRinteractive")
options(scipen = 999)
# Lectura de Datos
BASE <- read_excel("data/BASE.xlsx")
# Lectura del Shape de Colombia por Departamentos
Colombia = st_read(dsn = "data/Geodatabase Colombia", layer = "departamentos")
#Cruce de información con el shape cargado
Insumo = merge(Colombia, BASE, by.x="COD_DANE", by.y="Cod")
Insumo = subset(Insumo[c(1:31,33),])
# Conversión a Coordenadas UTM
Crs.geo = CRS("+proj=tmerc +lat_0=4.599047222222222 +lon_0=-74.08091666666667 +k=1 +x_0=1000000 +y_0=1000000 +ellps=intl +towgs84=307,304,-318,0,0,0,0 +units=m +no_defs")
proj4string(Insumo) <- Crs.geo
# Conversión a Coordenadas UTM
Crs.geo <- 4326  # Replace with your actual EPSG code or PROJ string
# Set CRS to the sf object
Insumo <- st_set_crs(Insumo, Crs.geo)
Insumo.utm = spTransform(Insumo, CRS("+init=epsg:3724 +units=km"))
Insumo.utm <- st_transform(Insumo, crs = 3724)
#---
# MATRIZ DE VECINDADES (W)
#---
## Centroides de las Áreas
Centros = getSpPPolygonsLabptSlots(Insumo.utm)
#---
# MATRIZ DE VECINDADES (W)
#---
## Centroides de las Áreas
Centros <- st_centroid(Insumo.utm)
#---
# MATRIZ DE VECINDADES (W)
#---
## Centroides de las Áreas
Centros <- st_centroid(Insumo.utm)
#---
# MATRIZ DE VECINDADES (W)
#---
## Centroides de las Áreas
Centros <- st_centroid(Insumo.utm)
Insumo.utm <- st_make_valid(Insumo.utm)
#---
# MATRIZ DE VECINDADES (W)
#---
## Centroides de las Áreas
Centros <- st_centroid(Insumo.utm)
#Cruce de información con el shape cargado
Insumo = merge(Colombia, BASE, by.x="COD_DANE", by.y="Cod")
Insumo = subset(Insumo[c(1:31,33),])
# Conversión a Coordenadas UTM
Crs.geo <- 4326  # Replace with your actual EPSG code or PROJ string
# Set CRS to the sf object
Insumo <- st_set_crs(Insumo, Crs.geo)
Insumo.utm <- st_make_valid(Insumo.utm)
#---
# MATRIZ DE VECINDADES (W)
#---
## Centroides de las Áreas
Centros = st_centroid(Insumo.utm)
nsumo.utm <- st_transform(Insumo, crs = 3724)
nsumo.utm <- st_transform(Insumo, crs = 4326)
Insumo.utm <- st_transform(Insumo, crs = 4326)
#---
# MATRIZ DE VECINDADES (W)
#---
## Centroides de las Áreas
Centros = st_centroid(Insumo.utm)
#Cruce de información con el shape cargado
Insumo = merge(Colombia, BASE, by.x="COD_DANE", by.y="Cod")
Insumo = subset(Insumo[c(1:31,33),])
# Conversión a Coordenadas UTM
Crs.geo = CRS("+proj=tmerc +lat_0=4.599047222222222 +lon_0=-74.08091666666667 +k=1 +x_0=1000000 +y_0=1000000 +ellps=intl +towgs84=307,304,-318,0,0,0,0 +units=m +no_defs")
proj4string(Insumo) <- Crs.geo
#Cruce de información con el shape cargado
Insumo = merge(Colombia, BASE, by.x="COD_DANE", by.y="Cod")
Insumo = subset(Insumo[c(1:31,33),])
# Conversión a Coordenadas UTM
Crs.geo = CRS("+proj=tmerc +lat_0=4.599047222222222 +lon_0=-74.08091666666667 +k=1 +x_0=1000000 +y_0=1000000 +ellps=intl +towgs84=307,304,-318,0,0,0,0 +units=m +no_defs")
Insumo <- st_set_crs(Insumo, Crs.geo)
Insumo.utm = spTransform(Insumo, CRS("+init=epsg:3724 +units=km"))
Insumo.utm = spTransform(Insumo, CRS("+init=epsg:3724 +units=km"))
Insumo.utm = st_transform(Insumo, CRS("+init=epsg:3724 +units=km"))
#---
# MATRIZ DE VECINDADES (W)
#---
## Centroides de las Áreas
Centros = getSpPPolygonsLabptSlots(Insumo.utm)
#---
# MATRIZ DE VECINDADES (W)
#---
## Centroides de las Áreas
Centros = st_centroid(Insumo.utm)
Centroids <- SpatialPointsDataFrame(coords = Centros,
data=Insumo.utm@data,
proj4string=CRS("+init=epsg:3724 +units=km"))
# Matriz de Distancias entre los Centriodes
Wdist = dist(Centros, up=T)
Centros_sp = as_Spatial(Centros)
Centroids <- SpatialPointsDataFrame(coords = Centros,
data=Insumo.utm@data,
proj4string=CRS("+init=epsg:3724 +units=km"))
Centroids <- SpatialPointsDataFrame(coords = Centros_sp,
data=Insumo.utm@data,
proj4string=CRS("+init=epsg:3724 +units=km"))
#---
# MATRIZ DE VECINDADES (W)
#---
## Centroides de las Áreas
Centros = st_centroid(Insumo.utm)
Centros_sp = as_Spatial(Centros)
Centroids <- SpatialPointsDataFrame(coords = Centros_sp,
data=Insumo.utm@data,
proj4string=CRS("+init=epsg:3724 +units=km"))
#  Mapa de Valores Observados
#dev.new() #windows()
choropleth(Insumo, Insumo$CAP_BAC)
rm(list=ls())
require(rgdal)
require(pscl)
require(sf)
require(spdep)
require(spatialreg) #test.W, scores.listw
require(stringr)
require(performance)
require(AER)
require(ggplot2)
require(vcdExtra)
require(dbscan)
quarto render
